<cms path="/getting_started" serve="true" type="html" locale="en_US" host="liftweb.net" valid_from="2010/09/01">
  <tag name="name" value="getting_started"/>
  <tag name="menu" value="Getting Started"/>
  <tag name="order" value="2"/>
  <content>
    <lift:surround with="default" at="content">
      <head>
		<title>Lift :: Getting Started</title>
		<script type="text/javascript" src="/javascript/shCore.js"></script>
		<script type="text/javascript" src="/javascript/shBrushScala.js"></script>
		<script type="text/javascript" src="/javascript/shBrushXml.js"></script>		

		<link type="text/css" rel="stylesheet" href="/style/shCoreRDark.css"/>
		<link type="text/css" rel="stylesheet" href="/style/shThemeRDark.css"/>
		<script type="text/javascript">SyntaxHighlighter.all();</script>
      </head>

      <div id="left">
	<h2>It's Chat App Time</h2>
	<p><strong>Author</strong>: Mads Hartmann Jensen <br/>
	  <strong>Code co-author</strong>: David Pollak</p>

	<p>I have the honor to represent the demo that David Pollak gives all
	  the time, it's the ubiquitous Lift chat app.</p>
	<p>In this article I'll show how you can create a comet-enabled chat
	  application using Lift. I will show all the code you need to get it
	  working and walk through the lines step by step to give you an
	  understanding of what's happening. In the end I'll show how to enhance
	  the application with some extra functionality and a few effects.</p>
	<p>Before we begin I want to say a quick word about comet in case it's
	  the first you've heard of it. Comet describes a model where the client
	  sends a request to the server. The request is hanging till the server
	  has something interesting to response. As soon as the server responses
	  another request is made. The idea is to give the impression that the
	  server is notifying the client of changes on the server.</p>
	<p>To get started download the <a
					href="https://github.com/lift/lift_22_sbt/tarball/2.2">TAR</a>
	  or <a href="https://github.com/lift/lift_22_sbt/zipball/2.2">Zip</a>
	  of the default Lift project and un-tar or un-zip the file.</p>

	<p>Now <em>cd</em> into the new folder and type <code>sbt update</code>
	  to grab the dependencies.</p>
	<p>Next, spark up your editor of choice and create the <em>src/main/scala/code/comet/Chat.scala</em>
	  file. Put the following code into Chat.scala:</p>
	<pre class="brush: scala;">package code
package comet

import net.liftweb._
import http._
import actor._
import util.Helpers._
import js._
import JsCmds._
import JE._

object ChatServer extends LiftActor with ListenerManager {
  private var messages = Vector("Welcome")

  def createUpdate = messages

  override def lowPriority = {
    case s: String => messages :+= s; updateListeners()
  }
}

class Chat extends CometActor with CometListener {
  private var msgs: Vector[String] = Vector()

  def registerWith = ChatServer

  override def lowPriority = {
    case v: Vector[String] => msgs = v; reRender()
  }

  def render = "li *" #> msgs

  override def fixedRender = {
    &lt;lift:form>
    {
      SHtml.text("", s => {
        ChatServer ! s
        SetValById("chat_box", "")
      }, "id" -> "chat_box")
    }
    &lt;input type="submit" value="Chat"/>
    &lt;/lift:form>
  }

}</pre>

	<p>Add the tag:     <pre>
      &lt;<span class="function-name">div</span> <span class="variable-name">class</span>=<span class="string">"lift:comet?type=Chat"</span>&gt;
        &lt;<span class="function-name">ul</span>&gt;
          &lt;<span class="function-name">li</span>&gt;line&lt;/<span class="function-name">li</span>&gt;
        &lt;/<span class="function-name">ul</span>&gt;
      &lt;/<span class="function-name">div</span>&gt;
</pre> to the existing <em>src/main/webapp/index.html</em> file and run the app by typing the following in your
	  console:</p>
	<pre><code>sbt ~jetty-run</code></pre>
	Now browse to <em>http://localhost:8080</em> with multiple browsers
	and you have your chat app. Pretty cool huh? Lets walk through the code
	to figure out how it all fits together.
	<pre class="brush: scala;">object ChatServer extends LiftActor with ListenerManager {
  private var messages = Vector("Welcome")

  def createUpdate = messages

  override def lowPriority = {
    case s: String => messages :+= s; updateListeners()
  }
}</pre>

	<p>We're doing a couple of things here. In the first line we're
	  defining a chat server as an object (singleton) that's a <a
								      href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/actor/LiftActor.html"
								      target="_blank">LiftActor</a> and that can manage listeners by mixing
	  in the <a
		    href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/ListenerManager.html"
		    target="_blank">ListenerManager</a> trait.</p>
	<p>In the implementation of our ChatServer we're creating a private
	  list of strings that we'll use to store the messages posted by the
	  clients. The createUpdate method is called when the updateListeners
	  method needs a message to send to the subscribed Actors. Here's it's
	  simply returning all the messages posted to the server.</p>
	<p>Lastly we're overriding the lowPriority method where we're pattern
	  matching against the messages sent to us. If the message is a string
	  we're simply adding it to the list of messages and telling all the
	  listeners that something happened by invoking the updateListeners
	  method which we got by mixing in the ListenerManager trait.</p>
	<p>lowPriority is just one of three methods (lowPriority,
	  mediumPriority, hightPriority) you can override to process the
	  messages. As the names may suggest the three methods let you
	  prioritize your messages.</p>
	<pre class="brush: scala;">class Chat extends CometActor with CometListener {</pre>
	<p>Here we're defining our chat component that knows how to push
	  updates to the browser and interact with the ChatServer.</p>

	<pre class="brush: scala;">private var msgs: Vector[String] = Vector()</pre>
	<p>This is where we'll store our local state.</p>
	<pre class="brush: scala;">def registerWith = ChatServer</pre>
	<p>Here the component is registrering itself with the ChatSever so it
	  will get notified of any changes. </p>
	<pre class="brush: scala;">override def lowPriority = {
  case v: Vector[String] =&gt; msgs = v; reRender()
}</pre>
	<p>This is where we implement how our component will handle the
	  messages from our ChatServer. We're simply updating our local state
	  (msgs) and invoking reRender().</p>

	<pre class="brush: scala;">  def render = "li *" #> msgs</pre>

	<p>Here we're telling the component how to render itself by creating
	  an <tt>li</tt> for each of our messages.</p>

	<p>
	  Finally, let's look at the input area that's fixed (it's
	  not redrawn on each reRender update):
	</p>

	<pre class="brush: scala">  override def fixedRender = {
    &lt;lift:form>
    {
      SHtml.text("", s => {
        ChatServer ! s
        SetValById("chat_box", "")
      }, "id" -> "chat_box")
    }
    &lt;input type="submit" value="Chat"/>
    &lt;/lift:form>
  }</pre>

	<p>
	  This code inserts an Ajax form into the page with an
	  input field.  When the form is submitted, the input
	  is sent to the <tt>ChatServer</tt> and JavaScript is
	  sent back to the browser that sets the input field to
	  blank.
	</p>
	
	<p>I hope this has helped you gain a better understanding of what the
	  code does. Now, it would be quite dull if all I did was recite the demo
	  that David has done numerous times - Lets see if I can't spice the demo
	  application up a bit to provide some extra functionality.</p>
	
	<hr/>
	
	<p>Lets add the following to our application</p>
	<ul>
	  <li>It should be possible to delete messages</li>
	  <li>When a message is deleted/added it should fade out/in</li>
	</ul>

	<p>Start by adding the following imports to your <em>src/main/scala/code/comet/Chat.scala</em>
	  file:</p>

	<pre class="brush: scala;">import js.jquery.JqJsCmds.{AppendHtml, FadeOut, Hide, FadeIn}
import java.util.Date
import scala.xml.{Text, NodeSeq}</pre>

	<p>Now that we've got the right classes imported lets start looking at
	  the actual code, again in your <em>src/main/scala/code/comet/Chat.scala</em>
	  file add the following:</p>
	<pre class="brush: scala;">final case class Message(msg: String, when: Date = new Date(), 
                         guid: String = nextFuncName)
final case class Remove(guid: String)</pre>

	<p>
	  We're creating two case classes (the final
	  keyword means you can't subclass them). We're going to send instances
	  of these classes between the client and server instead of strings as we
	  did earlier.
	</p>
	
	<p>The <code>nextFuncName</code> simply creates a unique
	  string for the message. We use
	  it here as a unique id.
	</p>

	<p>
	  Now lets take a look how we need to change the ChatServer:
	</p>
	<pre class="brush: scala;">object ChatServer extends LiftActor with ListenerManager {
  private var messages = Vector(Message("Welcome"))

  def createUpdate = messages

  override def lowPriority = {
    case s: String => {
      val m = Message(s)
      messages :+= m
      updateListeners(m -> messages)
    }

    case r @ Remove(guid) => {
      messages = messages.filterNot(_.guid == guid)
      updateListeners(r -> messages)
    }
  }
}</pre>

	<p>
	  Instead of using a list of strings to store our messages we're using
	  a list of Message.
	  The lowPriority message has also changed a bit.
	  We're handling Strings and converting them to Messages
	  and we're handling Remove messages as well.
	</p>

	<p>Finally lets take a look at the Chat. Replace the following
	  implementation of Chat with the one currently in your file:</p>
	<pre class="brush: scala;">class Chat extends CometActor with CometListener {
  private var msgs: Vector[Message] = Vector()

  def registerWith = ChatServer

  override def lowPriority = {
    case (Remove(guid), v: Vector[Message]) => {
      msgs = v
      partialUpdate(
        FadeOut(guid,TimeSpan(0),TimeSpan(500)) &amp;
        After(TimeSpan(500),Replace(guid, NodeSeq.Empty)))
    }

    case (m: Message, v: Vector[Message]) => {
      msgs = v
      partialUpdate(
        AppendHtml("ul_dude", doLine(m)(("li ^^" #> "^^")(defaultXml))) &amp;
        Hide(m.guid) &amp; FadeIn(m.guid, TimeSpan(0),TimeSpan(500)))
    }

    case v: Vector[Message] => msgs = v; reRender()
  }

  def render = "ul [id]" #> "ul_dude" &amp; "li" #> msgs.map(doLine)

  private def doLine(m: Message)(node: NodeSeq) = {
    ("li [id]" #> m.guid &amp; // set GUID
     // set body
     "li *" #> (Text(m.msg+" ") ++
                SHtml.ajaxButton("delete", () => {
                  ChatServer ! Remove(m.guid)
                  Noop
                })))(node)
  }

  override def fixedRender = {
    &lt;lift:form>
    {
      SHtml.text("", s => {
        ChatServer ! s
        SetValById("chat_box", "")
      }, "id" -> "chat_box")
    }
    &lt;input type="submit" value="Chat"/>
    &lt;/lift:form>
  }
}</pre>

	<p>Bam, If you restart the jetty server and browse to
	  http://localhost:8080 after pasting in the above code you should have a
	  chat application with fancy fading messages and the ability to delete
	  old messages. I hope this is enough to keep your motivated as we walk
	  through the code. Lets take it from the top:</p>
	<pre class="brush: scala;">class Chat extends CometActor with CometListener {
  private var msgs: Vector[Message] = Vector()

  def registerWith = ChatServer</pre>
	<p>We're declaring a list of Message which we'll use as our local state
	  (Message instead of String). We're still registering with
	  ChatServer.</p>
	<pre class="brush: scala;">  override def lowPriority = {
    case (Remove(guid), v: Vector[Message]) => {
      msgs = v
      partialUpdate(
        FadeOut(guid,TimeSpan(0),TimeSpan(500)) &amp;
        After(TimeSpan(500),Replace(guid, NodeSeq.Empty)))
    }

    case (m: Message, v: Vector[Message]) => {
      msgs = v
      partialUpdate(
        AppendHtml("ul_dude", doLine(m)(("li ^^" #> "^^")(defaultXml))) &amp;
        Hide(m.guid) &amp; FadeIn(m.guid, TimeSpan(0),TimeSpan(500)))
    }

    case v: Vector[Message] => msgs = v; reRender()
  }</pre>

	<p>Again, the lowPriority method is the one that deals with the
	  messages sent from the ChatServer. 
	  If we get a Remove message, do a partialUpdate
	  which sends the JavaScript to the browser
	  to update the list of messages (removing the <tt>&lt;li></tt>
	  with the <tt>id</tt> equal to the guid of the removed message).
	  We also update the current state... all the messages
	  in the list.
	  We do the same thing for new messages, except
	  add them to the display.</p>
	
	<p>We're calling partialUpdate which is declared in CometActor and
	  takes a <a
		     href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/JsCmd.html"
		     target="_blank">JsCmd</a> as it's only argument. As the name may
	  suggest partialUpdate is used to do partial updates of your comet
	  component.
	</p>

	<p>
	  The render method sets the <tt>id</tt> of the <tt>&lt;ul></tt>
	  so that we have a known place to insert the chat lines.
	  We also use a more complex method for generating 
	  the lines.  We're creating a function that returns a 
	  <code>NodeSeq => NodeSeq</code> for each line
	  in the chat.
	</p>
	
	<pre class="brush: scala;">  def render = "ul [id]" #> "ul_dude" &amp; "li" #> msgs.map(doLine)</pre>

	<p>The big change is how we create the lines:</p>
	<pre class="brush: scala;">  private def doLine(m: Message)(node: NodeSeq) = {
    ("li [id]" #> m.guid &amp; // set GUID
     // set body
     "li *" #> (Text(m.msg+" ") ++
                SHtml.ajaxButton("delete", () => {
                  ChatServer ! Remove(m.guid)
                  Noop
                })))(node)
  }</pre>

	<p>
	  We sset the <tt>id</tt> of the line and insert the 
	  message and an Ajax button into each line that
	  will allow us to delete the message.
	</p>


	<p>
	  Hopefully, this page gives you an idea of Lift's
	  Comet and Ajax power.  You can learn more about
	  Lift by reading 
	  <a href="http://simply.liftweb.net"><i>Simply Lift</i></a>
	  and 
	  <a href="http://exploring.liftweb.net"><i>Exploring Lift</i></a>.
	  <i>Simply Lift</i> is more focused on the Lift web framework
	  and <i>Exploring Lift</i> gives a broader over-view including
	  many different persistence options.
	</p>

	<p>
	  The source for this project is <a href="https://github.com/dpp/starting_point/tree/lift_22_example">available on GitHub</a>.
	</p>


      </div> <!-- left -->
    </lift:surround>
  </content>
</cms>
